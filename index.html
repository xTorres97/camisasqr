<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta - Centrado + Worker (fix coords)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    #overlayContainer{position:fixed; left:50%; top:50%; pointer-events:none; z-index:9999; display:none; transform-origin:center center; background:transparent; transform:translate(-50%,-50%);}
    #overlayContainer > video { display:block; width:100%; height:100%; background:transparent; object-fit:cover; }
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:10px 12px;border-radius:8px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:40}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40}
    #bigMatch{position:fixed;left:8px;top:48px;font-size:18px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}
    #forcePlay{position:fixed;left:50%;top:70%;transform:translate(-50%,-50%);z-index:10001;padding:12px 18px;background:#ff4fa8;color:#fff;border-radius:8px;border:none;display:none}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="overlayContainer"></div>

  <div id="controls">
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="testHide" class="ctrlBtn">Ocultar animación</button>
    <button id="toggleMode" class="ctrlBtn">Modo: Precisión</button>
  </div>

  <button id="startBtn">Activar AR</button>
  <button id="forcePlay">Toca para reproducir animación</button>

  <div id="log">iniciando...</div>
  <div id="bigMatch">Match: --</div>

<script>
/* ---------- CONFIG ---------- */
const TARGET_URL = './ilustracion.png';
const ANIM_URL = './Animacion.webm';

// modes & thresholds
let RES_SCALE = 0.70;
let FRAME_SKIP = 2;
let MODE = 'precision';

const REQUIRED_MATCHES = 10;
const REQUIRED_INLIERS = 8;
const CENTROID_THRESHOLD = 0.20; // puedes bajar a 0.15 si quieres más estricto
/* ---------------------------- */

const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const overlayContainer = document.getElementById('overlayContainer');
const startBtn = document.getElementById('startBtn');
const logEl = document.getElementById('log');
const bigMatch = document.getElementById('bigMatch');
const testShow = document.getElementById('testShow');
const testHide = document.getElementById('testHide');
const toggleMode = document.getElementById('toggleMode');
const forcePlay = document.getElementById('forcePlay');

let worker = null;
let streaming = false;
let procW = 1, procH = 1;
let offscreenForTransfer = null;
let frameCounter = 0;
let templW = 0, templH = 0;

function log(s){ logEl.textContent = s; console.log(s); }

const overlayVideoMarkup = (filename) => `
  <video id="fxVideo" autoplay loop muted playsinline preload="auto" crossorigin="anonymous" style="background:transparent;display:block;">
    <source src="${filename}" type="video/webm">
    <source src="${filename.replace('.webm','.mp4')}" type="video/mp4">
  </video>`;

function showOverlayCenteredFixed(sizePx){
  let w = sizePx;
  let h = Math.round(sizePx * (templH && templW ? (templH / templW) : 1));
  if (!templW || !templH) { h = w; }
  if (!document.getElementById('fxVideo')) overlayContainer.innerHTML = overlayVideoMarkup(ANIM_URL);
  const v = document.getElementById('fxVideo');
  overlayContainer.style.width = Math.max(10, w) + 'px';
  overlayContainer.style.height = Math.max(10, h) + 'px';
  overlayContainer.style.display = 'block';
  overlayContainer.style.visibility = 'visible';
  try { v.play().then(()=>{ log('video play ok'); forcePlay.style.display='none'; }).catch(e=>{ log('autoplay err'); forcePlay.style.display='block'; }); } catch(e){}
}
function hideOverlay(){ const fx = document.getElementById('fxVideo'); if (fx) try{ fx.pause(); }catch(e){} overlayContainer.style.display='none'; overlayContainer.style.visibility='hidden'; }

forcePlay.addEventListener('click', ()=>{ const fx = document.getElementById('fxVideo'); if (fx) fx.play().catch(()=>{}); forcePlay.style.display='none'; });
testShow.addEventListener('click', ()=> showOverlayCenteredFixed(Math.round(window.innerWidth*0.5)));
testHide.addEventListener('click', ()=> hideOverlay());

toggleMode.addEventListener('click', ()=>{
  if (MODE === 'precision'){
    MODE = 'speed'; RES_SCALE = 0.28; FRAME_SKIP = 4; toggleMode.textContent = 'Modo: Velocidad'; log('Modo velocidad');
  } else {
    MODE = 'precision'; RES_SCALE = 0.70; FRAME_SKIP = 2; toggleMode.textContent = 'Modo: Precisión'; log('Modo precisión');
  }
});

startBtn.addEventListener('click', async ()=>{ startBtn.style.display='none'; log('Activando cámara...'); await startCamera(); });

async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    cam.srcObject = stream;
    await cam.play();
    streaming = true;
    resizeCanvas();
    initWorker();
    scheduleFrame();
  } catch(e){ alert('Error al abrir la cámara: ' + e.message); console.error(e); }
}

function resizeCanvas(){
  overlay.width = cam.videoWidth; overlay.height = cam.videoHeight;
  overlay.style.width = cam.clientWidth + 'px'; overlay.style.height = cam.clientHeight + 'px';
  procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  try { offscreenForTransfer = new OffscreenCanvas(procW, procH); } catch(e) { const c = document.createElement('canvas'); c.width = procW; c.height = procH; offscreenForTransfer = c; }
}

/* worker init */
function initWorker(){
  if (worker) { worker.terminate(); worker = null; }
  worker = new Worker('worker.js');
  worker.onmessage = (ev)=>{
    const d = ev.data;
    if (d.type === 'ready'){ log('Worker ready — cargando template...'); worker.postMessage({type:'init', targetUrl: TARGET_URL, procW, procH}); }
    else if (d.type === 'log'){ console.log('worker:', d.msg); }
    else if (d.type === 'error'){ console.error('worker error:', d.msg); }
    else if (d.type === 'templateInfo'){ templW = d.w; templH = d.h; console.log('templ size from worker', templW, templH); }
    else if (d.type === 'result'){ handleWorkerResult(d); }
  };
}

/* NEW: improved mapping using video DOM rect (handles object-fit:cover cropping) */
function handleWorkerResult(d){
  bigMatch.textContent = `Matches: ${d.matches} | Inliers: ${d.inliers}`;

  // require corners and min thresholds
  if (!d.corners || d.matches < REQUIRED_MATCHES || d.inliers < REQUIRED_INLIERS){
    hideOverlay();
    return;
  }

  // get video bounding rect (displayed area)
  const vRect = cam.getBoundingClientRect();
  // scale from proc coords -> displayed video coords
  const scaleX_video = vRect.width / cam.videoWidth;
  const scaleY_video = vRect.height / cam.videoHeight;
  const videoLeft = vRect.left + window.scrollX;
  const videoTop = vRect.top + window.scrollY;

  // centroid in proc coords
  const cx_proc = (d.corners[0] + d.corners[2] + d.corners[4] + d.corners[6]) / 4.0;
  const cy_proc = (d.corners[1] + d.corners[3] + d.corners[5] + d.corners[7]) / 4.0;

  // map to screen (page) coordinates using displayed video scaling + offset
  const cx_screen = videoLeft + cx_proc * scaleX_video;
  const cy_screen = videoTop + cy_proc * scaleY_video;

  // screen center coords (page coords)
  const screenCenterX = window.scrollX + (window.innerWidth / 2);
  const screenCenterY = window.scrollY + (window.innerHeight / 2);

  // normalized distance to center (0..1 relative to diagonal)
  const dx = cx_screen - screenCenterX;
  const dy = cy_screen - screenCenterY;
  const diag = Math.hypot(window.innerWidth, window.innerHeight);
  const distNorm = Math.hypot(dx, dy) / diag;

  if (distNorm > CENTROID_THRESHOLD){
    hideOverlay();
    return;
  }

  // ok -> show centered overlay (no rotation)
  const sizePx = Math.round(Math.min(window.innerWidth * 0.6, window.innerHeight * 0.6));
  showOverlayCenteredFixed(sizePx);
}

/* send frame */
async function sendFrameToWorker(){
  if (!streaming || !worker) return;
  // update proc size if RES_SCALE changed
  const newW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  const newH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  if (newW !== procW || newH !== procH){ procW = newW; procH = newH; resizeCanvas(); worker.postMessage({type:'resize', procW, procH}); }

  try {
    const ctx2 = offscreenForTransfer.getContext('2d');
    ctx2.drawImage(cam, 0, 0, procW, procH);
    let bitmap;
    if (offscreenForTransfer.transferToImageBitmap){
      bitmap = offscreenForTransfer.transferToImageBitmap();
    } else {
      const blob = await new Promise(r=> offscreenForTransfer.toBlob(r,'image/png'));
      bitmap = await createImageBitmap(blob);
    }
    worker.postMessage({type:'frame', bitmap: bitmap}, [bitmap]);
  } catch(err){
    console.error('sendFrameToWorker err', err);
  }
}

/* scheduling */
function scheduleFrame(){
  if (!streaming) return;
  frameCounter = (frameCounter + 1) % FRAME_SKIP;
  if (cam.requestVideoFrameCallback){
    cam.requestVideoFrameCallback(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
  } else {
    requestAnimationFrame(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
  }
}

/* cleanup */
window.addEventListener('pagehide', ()=>{
  try{ if (worker) worker.terminate(); }catch(e){}
  try{ const s = cam.srcObject; if (s) s.getTracks().forEach(t=>t.stop()); }catch(e){}
});
</script>
</body>
</html>
