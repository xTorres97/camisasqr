<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta - Ilustración + Animación</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    /* contenedor para el overlay (video/webm con alpha) */
    #overlayContainer{
      position:fixed;
      left:0; top:0;
      pointer-events:none;
      z-index:9999;
      display:none;
      transform-origin:center center;
    }
    #overlayContainer > video, #overlayContainer > svg { display:block; width:100%; height:100%; }
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:10px 12px;border-radius:8px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:40}
    #note{position:fixed;left:0;right:0;bottom:10px;text-align:center;z-index:40;opacity:0.9}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40}
    #bigMatch{position:fixed;left:8px;top:48px;font-size:20px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <!-- Contenedor donde inyectamos el webm (transparente si webm tiene alpha) -->
  <div id="overlayContainer"><!-- contenido se inyecta dinámicamente --></div>

  <div id="controls">
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="testHide" class="ctrlBtn">Ocultar animación</button>
  </div>

  <button id="startBtn">Activar AR</button>
  <div id="note">Apunta la cámara hacia la imagen de la camiseta</div>
  <div id="log">listo</div>
  <div id="bigMatch">Match: --</div>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* CONFIG */
const TARGET_URL = './ilustracion.png';   // tu imagen marker
let RES_SCALE = 0.7;
let FRAME_SKIP = 2;
let MATCH_RATIO = 0.75;
let minMatchCount = 6;

/* DOM */
const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startBtn = document.getElementById('startBtn');
const logEl = document.getElementById('log');
const bigMatch = document.getElementById('bigMatch');
const overlayContainer = document.getElementById('overlayContainer');
const testShow = document.getElementById('testShow');
const testHide = document.getElementById('testHide');

function log(s){ logEl.textContent = s; console.log(s); }

/* video overlay markup (we insert this when needed) */
const overlayVideoMarkup = (filename) => `
  <video id="fxVideo" autoplay loop muted playsinline preload="auto" crossorigin="anonymous" style="will-change:transform; display:block;">
    <source src="${filename}" type="video/webm">
    <!-- fallback: if webm not supported, try mp4 -->
    <source src="${filename.replace('.webm','.mp4')}" type="video/mp4">
  </video>`;

/* helper show/hide the overlay video centered & rotated */
function showOverlayCentered(cx, cy, w, h, angleDeg = 0){
  // cx,cy in overlay canvas pixels (center)
  const rect = overlay.getBoundingClientRect();
  const screenX = rect.left + cx + window.scrollX;
  const screenY = rect.top + cy + window.scrollY;

  // make sure video element exists
  if (!document.getElementById('fxVideo')){
    overlayContainer.innerHTML = overlayVideoMarkup('./Animacion.webm');
  }
  const fx = document.getElementById('fxVideo');
  overlayContainer.style.left = screenX + 'px';
  overlayContainer.style.top  = screenY + 'px';
  overlayContainer.style.width = Math.max(10, w) + 'px';
  overlayContainer.style.height = Math.max(10, h) + 'px';
  overlayContainer.style.display = 'block';
  overlayContainer.style.visibility = 'visible';
  overlayContainer.style.transform = `translate(-50%,-50%) rotate(${angleDeg}deg)`;
  // style video to fill container
  fx.style.width = '100%'; fx.style.height = '100%'; fx.style.objectFit = 'cover';

  // play (autoplay might be blocked; catch)
  fx.play().catch(e => { log('Autoplay error: ' + e); /* user must tap to allow */ });
}
function hideOverlay(){
  const fx = document.getElementById('fxVideo');
  if (fx) try{ fx.pause(); } catch(e){}
  overlayContainer.style.display = 'none';
}

/* rest of ORB/OpenCV code is same pattern as antes (prepareOpenCV, processFrame) */
/* For brevity I keep same logic as last working index but adapted to use overlay functions above. */

let videoStream = null, streaming = false;
let srcMat=null, grayMat=null, templMat=null, templGray=null;
let procCanvas=null, procCtx=null;
let orb=null, bf=null, templKeypoints=null, templDescriptors=null;
let frameCounter = 0;

async function startCamera(){
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    cam.srcObject = videoStream;
    await cam.play();
    streaming = true;
    resizeCanvas();
    prepareOpenCV();
  } catch(e){ alert('Error cámara: ' + e.message); console.error(e); }
}
function stopCamera(){ if (videoStream) videoStream.getTracks().forEach(t=>t.stop()); streaming=false; }
function resizeCanvas(){ overlay.width = cam.videoWidth; overlay.height = cam.videoHeight; overlay.style.width = cam.clientWidth + 'px'; overlay.style.height = cam.clientHeight + 'px'; }

async function prepareOpenCV(){
  log('Esperando OpenCV...');
  if (typeof cv === 'undefined' || !cv.imread){
    let waited=0;
    while((typeof cv === 'undefined' || !cv.imread) && waited<5000){ await new Promise(r=>setTimeout(r,100)); waited+=100; }
  }
  if (typeof cv === 'undefined' || !cv.imread){ alert('OpenCV no cargó'); return; }

  log('OpenCV listo — cargando marker...');
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = TARGET_URL + '?v=' + Date.now();
  img.onload = () => {
    const tmp = document.createElement('canvas');
    tmp.width = img.width; tmp.height = img.height;
    tmp.getContext('2d').drawImage(img,0,0);
    if (templMat) templMat.delete(); if (templGray) templGray.delete();
    templMat = cv.imread(tmp);
    templGray = new cv.Mat();
    cv.cvtColor(templMat, templGray, cv.COLOR_RGBA2GRAY);
    // init ORB & BFMatcher
    try { orb = new cv.ORB(); } catch(e){ console.warn('ORB init err', e); }
    bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
    templKeypoints = new cv.KeyPointVector();
    templDescriptors = new cv.Mat();
    try { orb.detect(templGray, templKeypoints); orb.compute(templGray, templKeypoints, templDescriptors); }
    catch(e){ try { orb.detectAndCompute(templGray, new cv.Mat(), templKeypoints, templDescriptors); } catch(err){ alert('ORB error en template'); return; } }
    log('Template KP: ' + templKeypoints.size());
    const procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    procCanvas = document.createElement('canvas'); procCanvas.width = procW; procCanvas.height = procH;
    procCtx = procCanvas.getContext('2d', { willReadFrequently:true });
    if (srcMat) srcMat.delete(); if (grayMat) grayMat.delete();
    srcMat = new cv.Mat(procH, procW, cv.CV_8UC4);
    grayMat = new cv.Mat(procH, procW, cv.CV_8UC1);
    requestAnimationFrame(processFrame);
  };
  img.onerror = e => { alert('No se pudo cargar ' + TARGET_URL); console.error(e); };
}

function processFrame(now){
  if (!streaming) return;
  try {
    frameCounter = (frameCounter + 1) % FRAME_SKIP;
    const pW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const pH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    if (!procCanvas || procCanvas.width !== pW || procCanvas.height !== pH){
      if (srcMat) srcMat.delete(); if (grayMat) grayMat.delete();
      procCanvas = document.createElement('canvas'); procCanvas.width = pW; procCanvas.height = pH;
      procCtx = procCanvas.getContext('2d', { willReadFrequently:true });
      srcMat = new cv.Mat(pH, pW, cv.CV_8UC4); grayMat = new cv.Mat(pH, pW, cv.CV_8UC1);
      log('Reiniciado procesador ' + pW + 'x' + pH);
    }
    procCtx.drawImage(cam,0,0,pW,pH);
    const imageData = procCtx.getImageData(0,0,pW,pH);
    if (srcMat && srcMat.data && srcMat.data.length === imageData.data.length) srcMat.data.set(imageData.data);
    else srcMat = cv.imread(procCanvas);
    if (frameCounter !== 0){ requestAnimationFrame(processFrame); return; }
    cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);
    let frameKeypoints = new cv.KeyPointVector(); let frameDescriptors = new cv.Mat();
    try { orb.detect(grayMat, frameKeypoints); orb.compute(grayMat, frameKeypoints, frameDescriptors); }
    catch(e){ try{ orb.detectAndCompute(grayMat, new cv.Mat(), frameKeypoints, frameDescriptors); } catch(err){ frameKeypoints.delete(); frameDescriptors.delete(); requestAnimationFrame(processFrame); return; } }
    const tplK = templKeypoints ? templKeypoints.size() : 0;
    const frmK = frameKeypoints ? frameKeypoints.size() : 0;
    if (!tplK || !frmK){ ctx.clearRect(0,0,overlay.width,overlay.height); ctx.fillStyle='white'; ctx.fillText('Match: --',10,20); frameKeypoints.delete(); frameDescriptors.delete(); hideOverlay(); requestAnimationFrame(processFrame); return; }
    let matches = new cv.DMatchVectorVector();
    try { bf.knnMatch(frameDescriptors, templDescriptors, matches, 2); } catch(e){ matches.delete(); frameKeypoints.delete(); frameDescriptors.delete(); requestAnimationFrame(processFrame); return; }
    let goodMatches = [];
    for (let i=0;i<matches.size();i++){
      const mv = matches.get(i);
      if (mv.size()>=2){ const m=mv.get(0), n=mv.get(1); if (m.distance <= MATCH_RATIO*n.distance) goodMatches.push({queryIdx:m.queryIdx, trainIdx:m.trainIdx}); }
      else if (mv.size()===1){ const m=mv.get(0); if (m.distance < 30) goodMatches.push({queryIdx:m.queryIdx, trainIdx:m.trainIdx}); }
      mv.delete();
    }
    matches.delete();
    if (goodMatches.length < minMatchCount){ frameKeypoints.delete(); frameDescriptors.delete(); ctx.clearRect(0,0,overlay.width,overlay.height); ctx.fillText('Matches:'+goodMatches.length,10,20); bigMatch.textContent = 'Matches: ' + goodMatches.length; hideOverlay(); requestAnimationFrame(processFrame); return; }
    const srcPts=[]; const dstPts=[];
    for (let i=0;i<goodMatches.length;i++){ const gm = goodMatches[i]; const kpF = frameKeypoints.get(gm.queryIdx); const kpT = templKeypoints.get(gm.trainIdx); srcPts.push(kpF.pt.x,kpF.pt.y); dstPts.push(kpT.pt.x,kpT.pt.y); }
    let srcMatPts = cv.matFromArray(goodMatches.length,1,cv.CV_32FC2, srcPts);
    let dstMatPts = cv.matFromArray(goodMatches.length,1,cv.CV_32FC2, dstPts);
    let mask = new cv.Mat();
    let H = cv.findHomography(srcMatPts, dstMatPts, cv.RANSAC, 5.0, mask);
    let inliers=0; for (let i=0;i<mask.rows;i++) if (mask.ucharPtr(i,0)[0]) inliers++;
    ctx.clearRect(0,0,overlay.width, overlay.height);
    ctx.fillStyle='white'; ctx.font='16px Arial'; ctx.fillText('Matches:' + goodMatches.length + ' inliers:' + inliers,10,20);
    bigMatch.textContent = 'Matches: ' + goodMatches.length + ' | Inliers: ' + inliers;
    if (!H.empty() && inliers >= Math.max(5, Math.floor(goodMatches.length*0.25))){
      let H_inv = new cv.Mat(); cv.invert(H, H_inv, cv.DECOMP_LU);
      const tw = templGray.cols, th = templGray.rows;
      const tplCorners = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, tw,0, tw,th, 0,th]);
      let dstCorners = new cv.Mat();
      cv.perspectiveTransform(tplCorners, dstCorners, H_inv);
      const scaleX = overlay.width / srcMat.cols;
      const scaleY = overlay.height / srcMat.rows;
      const x0 = dstCorners.floatAt(0,0), y0 = dstCorners.floatAt(0,1);
      const x1 = dstCorners.floatAt(1,0), y1 = dstCorners.floatAt(1,1);
      const x2 = dstCorners.floatAt(2,0), y2 = dstCorners.floatAt(2,1);
      const x3 = dstCorners.floatAt(3,0), y3 = dstCorners.floatAt(3,1);
      const minX = Math.min(x0,x1,x2,x3), maxX = Math.max(x0,x1,x2,x3);
      const minY = Math.min(y0,y1,y2,y3), maxY = Math.max(y0,y1,y2,y3);
      const centerX = (minX+maxX)/2, centerY=(minY+maxY)/2;
      const drawW = (maxX-minX)*scaleX, drawH = (maxY-minY)*scaleY;
      const drawCX = centerX*scaleX, drawCY = centerY*scaleY;
      const angleRad = Math.atan2(y1-y0, x1-x0); const angleDeg = angleRad*180/Math.PI;
      ctx.strokeStyle='rgba(0,255,150,0.95)'; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(x0*scaleX,y0*scaleY); ctx.lineTo(x1*scaleX,y1*scaleY); ctx.lineTo(x2*scaleX,y2*scaleY); ctx.lineTo(x3*scaleX,y3*scaleY); ctx.closePath(); ctx.stroke();
      // show overlay (video with alpha)
      showOverlayCentered(drawCX, drawCY, drawW, drawH, angleDeg);
      tplCorners.delete(); dstCorners.delete(); H_inv.delete();
    } else {
      hideOverlay();
    }
    srcMatPts.delete(); dstMatPts.delete(); mask.delete(); if (H && !H.isDeleted) H.delete();
    frameKeypoints.delete(); frameDescriptors.delete();
  } catch(err){
    console.error('Error procesando', err);
  } finally {
    requestAnimationFrame(processFrame);
  }
}

/* start button & test controls */
startBtn.addEventListener('click', async ()=>{ startBtn.style.display='none'; log('Activando cámara...'); await startCamera(); });
testShow.addEventListener('click', ()=>{ const r = overlay.getBoundingClientRect(); showOverlayCentered(r.width/2, r.height/2, r.width*0.5, r.height*0.5, 0); });
testHide.addEventListener('click', ()=>{ hideOverlay(); });

/* cleanup */
window.addEventListener('pagehide', ()=>{ try{ if (srcMat) srcMat.delete(); if (grayMat) grayMat.delete(); if (templMat) templMat.delete(); if (templGray) templGray.delete(); if (templKeypoints) templKeypoints.delete(); if (templDescriptors) templDescriptors.delete(); }catch(e){} stopCamera(); });
</script>
</body>
</html>
